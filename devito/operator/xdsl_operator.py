from devito import Operator
from devito.ir.ietxdsl import transform_devito_to_iet_ssa, iet_to_standard_mlir
from devito.logger import perf

import os, shlex, sys

import tempfile

import subprocess

from io import StringIO


from xdsl.printer import Printer

__all__ = ['XDSLOperator']


class XDSLOperator(Operator):
    """

    How to backdoor JIT COMPILATION WITH XDSLOperator:

    ```
    `DUMP_MLIR=1 <devito command>`

    Observe the line
    > printed unoptimized mlir module to /run/user/1000/hash.so.iet.mlir
    in the program output

    Copy and edit the file however you like.
    Check the debugging info in `debug.c`

    To rerun, pass the .mlir file as an env var arg to JIT_BACKDOOR:
    Once you are satisfied, run `JIT_BACKDOOR=/path/to/your/source.mlir <devito command>`

    Make sure that the debug.c file is located in the directory where you invoke the
    python script command so that we can find it and link it with the mlir code.
    """

    def __new__(cls, expressions, **kwargs):
        self = super(XDSLOperator, cls).__new__(cls, expressions, **kwargs)
        self._tf = tempfile.NamedTemporaryFile(suffix='.so')
        self.__class__ = cls
        return self

    def _jit_compile(self):
        """
        JIT-compile the C code generated by the Operator.
        It is ensured that JIT compilation will only be performed once per
        Operator, reagardless of how many times this method is invoked.
        """
        # ccode = transform_devito_xdsl_string(self)
        # self.ccode = ccode

        with self._profiler.timer_on('jit-compile'):
            perf("***\nLowering a Devito Operator to a ModuleOp")
            module_obj = transform_devito_to_iet_ssa(self)

            perf("***\nLowering from IET_SSA to standard MLIR")
            iet_to_standard_mlir(module_obj)

            module_str = StringIO()
            Printer(target=Printer.Target.MLIR, stream=module_str).print(module_obj)
            module_str = module_str.getvalue()

            f = self._tf.name

            try:
                nixos_compiler_prefix = ""
                # detect nixos
                if 'NIX_STORE' in os.environ:
                    # use steam-run to get around problems with unwrapped clang binaries
                    # make sure you have steam-run in your environment
                    # > nix-shell -p steam-run
                    nixos_compiler_prefix = "steam-run "

                # JIT_BACKDOOR contains the path to the mlir file we should use
                backdoor = os.environ.get('JIT_BACKDOOR')

                # pre-compile debug.o because of some difficulties 
                # encountered with clang on NixOs :)
                if not os.path.exists('debug.o'):
                    if not os.path.exists('debug.c'):
                        print("ERROR: Please make sure you have either debug.c or debug.o in the directory where you invode devito!")
                        sys.exit(1)
                    else:
                        perf("Compiling debug.o from debug.c")
                        cc = os.environ.get('CC', 'gcc')
                        subprocess.run([cc, '-c', 'debug.c', '-o', 'debug.o'])

                if backdoor is not None:
                    res = subprocess.run(
                        f'cat {shlex.quote(backdoor)} | '
                        f'mlir-opt -cse -loop-invariant-code-motion | '
                        f'mlir-opt -convert-scf-to-cf -convert-cf-to-llvm -convert-arith-to-llvm -convert-math-to-llvm -convert-func-to-llvm -reconcile-unrealized-casts | '
                        f'mlir-translate --mlir-to-llvmir > llvm.ll && '
                        + nixos_compiler_prefix+ f' clang -O3 -shared llvm.ll debug.o -o {self._tf.name}',
                        shell=True,
                        text=True
                    )

                else:
                    dump_mlir = 'DUMP_MLIR' in os.environ or True
                    if dump_mlir:
                        perf(f"Saved/printed unoptimized mlir module to {f}.iet.mlir")
                    res = subprocess.run(
                        (f'tee {f}.iet.mlir |' if dump_mlir else '') +
                        f'mlir-opt -cse -loop-invariant-code-motion | '
                        f'mlir-opt -convert-scf-to-cf -convert-cf-to-llvm -convert-arith-to-llvm -convert-math-to-llvm -convert-func-to-llvm -reconcile-unrealized-casts | '
                        f'mlir-translate --mlir-to-llvmir | '
                        + nixos_compiler_prefix+ f' clang -O3 -shared -xir - -o {self._tf.name}',
                        shell=True,
                        input=module_str,
                        text=True
                    )
                # Subprocess completed succesfully
                assert res.returncode == 0
            except Exception as ex:
                print("error")
                raise ex

        elapsed = self._profiler.py_timers['jit-compile']

        perf("XDSLOperator `%s` jit-compiled `%s` in %.2f s with `mlir-opt`" %
             (self.name, self._tf.name, elapsed))

    @property
    def _soname(self):
        return self._tf.name

    @property
    def cfunction(self):
        """The JIT-compiled C function as a ctypes.FuncPtr object."""
        if self._lib is None:
            self._jit_compile()
            self._lib = self._compiler.load(self._tf.name)
            self._lib.name = self._tf.name

        if self._cfunction is None:
            self._cfunction = getattr(self._lib, self.name)
            # Associate a C type to each argument for runtime type check
            self._cfunction.argtypes = [i._C_ctype for i in self.parameters]

        return self._cfunction
